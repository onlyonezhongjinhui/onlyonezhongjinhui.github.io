---
title: MySQL默认隔离级别是什么
date: 2021-05-19 22:20:00
author: maybe
top: false
cover: false
toc: false
mathjax: false
summary:
tags: MySQL
categories:
- [MySQL]
---

SQL标准事务隔离级别有：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）、串行化（serializable）。这几种隔离级别由低到高，效率由高到低。

#### 读未提交

一个事务还未提交，它所作的变更就被其它的事务所看到。

#### 读提交

一个事务的修改只有在它提交以后其他事务才能看到。

#### 可重复读

在读提交的基础上，保证一个事务在执行的过程中看到的数据总是和在这个事务启动的时候看到的数据是一致的。

#### 串行化

对同一行数据的修改，后一个事务必须要等待前一个事务完成。也就是说对同一行数据，读会加上读锁，写会加上写锁。

有这么四种隔离级别 ，那么MySQL是默认哪一种呢？

mysql> show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+

事实证明**MySQL的默认隔离级别是可重复读**，Oracle默认是读提交，所以当Oracle迁移到MySQL的时候注意设置MySQL的隔离级别为读提交哦。

举个栗子来看看各个隔离级别的表现，加深理解。创建一个表t,并预置一行数据：

```sql
create table t(c int) engine=InnoDB;
insert into t(c) values(1);
```

创建两个session会话，分别启动两个事务，它们的执行顺序如下所示：

```
session1                | session2
------------------------------------------------------------- 
begin;                    begin;
-------------------------------------------------------------
select * from t; (c=1)
-------------------------------------------------------------
                          select * from t; (c=1)
-------------------------------------------------------------
                          update t set c = 2 where c = 1;
-------------------------------------------------------------
select * from t; (c=?);
-------------------------------------------------------------
                          commit;
-------------------------------------------------------------
select * from t; (c=?);
-------------------------------------------------------------
commit;
-------------------------------------------------------------
select * from t; (c=?);
-------------------------------------------------------------
```

##### 读未提交

第一个问号里c=2，第二个问好c=2，第三个问好c=2

##### 读已提交

第一个问号里c=1，第二个问好c=2，第三个问好c=2

##### 可重复读

第一个问号里c=1，第二个问好c=1，第三个问好c=2。

##### 串行化

第一个问号里c=1，第二个问好c=1，第三个问好c=2。需要注意的是，session2中的事务执行update语句的时候会申请写锁所以会被卡住，只有当session1中的事务提交后session2中的语句才能继续执行。

实际上，在数据库中会创建一个视图，访问的时候以这个视图的逻辑结果为准。在**读未提交**隔离级别下，实际上是不存在视图的概念，因为每次都是返回最新的值。在**读提交**隔离级别下，这个视图是每个SQL语句开始执行的时候创建的。在**可重复读**隔离级别下，这个视图是在事务启动的时候创建的，整个事务过程中都是使用这个视图。在**串行化**隔离级别下直接通过加锁的方式避免并行访问。

## 小结

* MySQL默认隔离级别是可重复读。
* 隔离级别有四种，读未提交、读提交、可重复读、串行化，并行效率依次从高到低。